from ZeroSubClasses import *
from typing import List


# Класс Parser НЕ наследуется от ZeroEntity,
# тк ему не нужен get_fields()
class Parser:
    """Класс Парсера \n
       ПОЛЯ (7): \n
       1.Карты \n
       2.Начальная строка \n
       3.Пользовательская строка (меняется от вызова к вызову warp_drive'а) \n
       4.Текущая преобразуемая строка \n
       5.Замены \n
       6.Ошибки \n
       7.Объект результата (класса Result)"""

    # инициализирует все поля
    def __init__(self, cards: List[Card], inp_str: str):
        """Устанавливает и хранит 7 полей \n
           1.Карты \n
           2.Начальная строка \n
           3.Пользовательская строка (меняется от вызова к вызову warp_drive'а) \n
           4.Текущая преобразуемая строка \n
           5.Замены \n
           6.Ошибки \n
           7.Объект результата (класса Result)"""
        self._cards = cards
        self._first_str = inp_str
        self._user_str = None
        self._str = inp_str
        self._swaps = []
        self._errors = Errors()
        self._errors.no_errors()
        self._res = Result([], ResStrStruct('', '', ''), self._errors)

        # Не обязательно, если вызывается внутри каждого метода Error, где копится ошибка
        # self._errors.no_errors()

        self._res = Result([], ResStrStruct('', '', ''), self._errors)

    @staticmethod
    def _suitable_val_entry_in_str(sentence: str,
                                   words_data_list: List[List[str | Card]]) -> (List[str | int | Card] |
                                                                                None):
        """Получает на вход строку и список из подсписков из \n
             имени, \n
             нужного значения карточки, \n
             самой карты (нужно для свапов при обратных заменах) \n
        \n
           Возвращает подходящее вхождение в строку \n
            из множества значений нужного типа \n
            в формате [link_name, link_val, card, pos] \n
            или None, если вхождений нет \n
        \n
           1. Принимаем за потенциальный ответ None. \n
               Если не будет найдено ни одного вхождения, результат = None! \n
           2. Бежим по входной строке. \n
           3. На каждом шаге сортируем по длине от самой короткой до самой длинной все входные строки, \n
               начинающиеся на текущий символ. \n
           4. Спрашиваем для каждой, входит ли она полностью во входную строку. \n
           5. Если да, заменяем потенциальный ответ на более длинный. \n
               и дополняем позицию первого вхождения в возвращаемый результат \n
           6. Если нет, просто едем дальше. \n
           7. Если найдено хотя бы одно вхождение строки - прерываем цикл \n
           8. Если нет, возвращаем список типа words_data из одного word'а и card'а."""

        # 1. Принимаем за потенциальный ответ None.
        #                Если не будет найдено ни одного вхождения, результат = None!
        res_word_data = None

        # 2. Бежим по входной строке.
        for char in sentence:

            # 3. На каждом шаге сортируем по длине от самой короткой до самой длинной все входные строки,
            #                начинающиеся на текущий символ.
            matched_words_data_list = sorted([data for data in words_data_list if data[1][0] == char], key=len)

            # 4. Спрашиваем для каждой, входит ли она полностью во входную строку.
            # 5. Если да, заменяем потенциальный ответ на более длинный
            #     и дополняем позицию первого вхождения в возвращаемый результат
            for matched_words_data in matched_words_data_list:
                if matched_words_data[1] in sentence:
                    first_entry = sentence.find(matched_words_data[1])
                    res_word_data = matched_words_data + [first_entry]

            # 6. Если нет, просто едем дальше.
            # 7. Если найдено хотя бы одна вхождение строки - прерываем цикл
            if res_word_data is not None:
                # print('FINISH', res_word_data)
                break

        # 8. Когда вся строка перебрана, вернуть список типа words_data с word'ами и card'ами.
        return res_word_data

    def _do_swaps(self, words: List[List[str | Card]]) -> bool:
        """ Замены (см. п. 4 ниже)
        \n
            Принимает на вход список из подсписков из \n
             -имени карты, \n
             -значения нужного типа, \n
             -ссылки на карту. \n
        \n
            Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
           2. Пока есть вхождения (прерывание с условием внутри цикла) \n
           3. Получаем результат-структуру после поиска вхождений в строку обычных значений \n
           4. Условие прерывания (если больше НЕТ вхождений) \n
           5. Если вхождение есть...: \n
           5.1 Переключаем флажок присутствия замен на True
           5.2 Находим из найденной структуры выше \n
                имя, \n
                одно значение, подходящее по вхождению, \n
                соответствующую карту, \n
                и позицию вхождения значения \n
           5.3 Сохраняем последнее состояние строки \n
           5.4 Обновляем состояние строки: \n
               Заменяем в строке значение на имя \n
           5.5 Формируем текущий свап: \n
                сохраняем последнее состояние строки, \n
                новое, \n
                значение замены, \n
                нужное имя, \n
                позицию замены, \n
                и соответствующую карточку \n
           5.6 Добавляем текущий сформированный свап в общий список свапов \n
           6. Возвращаем состояние флажка присутствия замен"""

        # 1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
        swapped = False

        # 2. Пока есть вхождения (прерывание с условием внутри цикла)
        while True:

            # 3. Получаем результат-структуру после поиска вхождений в строку обычных значений
            found_val = self._suitable_val_entry_in_str(self._str, words)
            # print(found_val)

            # 4. Условие прерывания (если больше НЕТ вхождений)
            if found_val is None:
                break

            # 5. Если вхождение есть...:
            else:

                # 5.1 Переключаем флажок присутствия замен на True
                swapped = True

                # 5.2 Находим из найденной структуры выше
                #      имя,
                #      одно значение, подходящее по вхождению,
                #      соответствующую карту,
                #      и позицию вхождения значения
                found_link_name, found_link_val, found_card, found_pos = found_val

                # 5.3 Сохраняем последнее состояние строки
                last_version_of_str = self._str

                # 5.4 Обновляем состояние строки:
                #     Заменяем в строке значение на имя
                self._str = self._str.replace(found_link_val, found_link_name, 1)

                # 5.5 Формируем текущий свап:
                #      сохраняем последнее состояние строки,
                #      новое,
                #      значение замены,
                #      нужное имя,
                #      позицию замены,
                #      и соответствующую карточку
                cur_swap = OneSwap(last_version_of_str, self._str, found_link_val,
                                   found_link_name, found_pos, found_card)

                # 5.6 Добавляем текущий сформированный свап в общий список свапов
                self._swaps += [cur_swap]

        # 6. Возвращаем состояние флажка присутствия замен
        return swapped

    def _simple_swaps(self) -> bool:
        """Прямые замены \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Формируем список из подсписков из \n
               -имени карты, \n
               -значения нужного типа, \n
               -ссылки на карту. \n
           2. Выполняем простые замены \n
               и одним махом возвращаем информацию о присутствии замен"""

        # 1. Формируем список из подсписков из
        #      -имени карты,
        #      -значения нужного типа,
        #      -ссылки на карту.
        words = [[[card.name, val, card] for val in card.usual_vals] for card in self._cards][0]
        # print(words)

        # 2. Выполняем простые замены
        #     и одним махом возвращаем информацию о присутствии замен
        return self._do_swaps(words)

    def _templates_swaps(self) -> bool:
        """Замены по шаблону (БЕЗ ОБРАТНЫХ!!) \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Формируем список из подсписков из \n
               -имени карты, \n
               -значения нужного типа, \n
               -ссылки на карту. \n
           2. Выполняем замены по шаблону (БЕЗ ОБРАТНЫХ!!)
               и одним махом возвращаем информацию о присутствии замен
        """

        # 1. Формируем список из подсписков из
        #      -имени карты,
        #      -значения нужного типа,
        #      -ссылки на карту.
        words = [[[one_template.name, one_template.val, card] for one_template in card.templates][0]
                 for card in self._cards if card.templates]
        # print(words)

        # 2. Выполняем замены по шаблону (БЕЗ ОБРАТНЫХ!!)
        #     и одним махом возвращаем информацию о присутствии замен
        return self._do_swaps(words)

    @staticmethod
    def _collision_occurred(links_data: dict) -> bool:
        """Определяет, произошла ли коллизия при последней замене по шаблону \n
            из всех локальных свапов, пришедших извне \n
         \n
           Принимает локальные свапы после предпоследнего шаблонного. \n
           Возвращает True, если коллизия была, \n
            и False, если не произошла \n
            (те если все значения совпадают в рамках каждого типа). \n
         \n
           1. Создаем список под каждую возможную коллизию под ссылку каждого типа \n
           2. Бежим по локальным свапам \n
           3. Дополняем в список возможных коллизий итоговый ответ для каждого типа ссылки \n
           4. Если была хотя бы одна коллизия - возвращаем False"""

        # 1. Создаем список под каждую возможную коллизию под ссылку каждого типа
        collisions_list = []

        # 2. Бежим по локальным свапам
        for one_link_data in links_data:
            # 3. Дополняем в список возможных коллизий итоговый ответ для каждого типа ссылки
            collisions_list += [len(links_data[one_link_data]) != 1]

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # Смотрим на collisions_list
        # print(collisions_list)

        # 4. Если была хотя бы одна коллизия - возвращаем False
        return True in collisions_list

    @staticmethod
    def _get_links_data(local_swaps: List[OneSwap]) -> dict:
        """Возвращает значения ссылок, расфасованные по типам \n
         \n
           Принимает локальные свапы после предпоследнего шаблонного (РАЗВЕРНУТЫЕ!!!). \n
           Возвращает dict() с ключами = именам ссылок последней шаблонной замены \n
            и значениями = значениями каждой ссылки \n
            между последней и предпоследней шаблонной \n
         \n
           1. Создаем словарь для имен (в качестве ключа) и значений (в качестве значений в списке) ссылок \n
           2. Заполняем ключи нетерминалами ссылок из последнего шаблонного свапа \n
           2.1 Не имеет значения, брать терминал или нетерминал, \n
                так как и то и то в равной степени входит в шаблон \n
           3. Бежим по локальным свапам перед последним шаблонным в обратном порядке \n
           4. Если замещающее значение в текущем свапе \n
               совпадает с нетерминалом какой-то ссылки в последнем шаблонном свапе, \n
               дополняем в список-значение словаря заменяемый терминал (значение ссылки) \n
           5. Возвращаем информацию о ссылках"""

        # 1. Создаем словарь для имен (в качестве ключа) и значений (в качестве значений в списке) ссылок
        links_names = dict()

        # 2. Заполняем ключи нетерминалами ссылок из последнего шаблонного свапа
        for one_templ in local_swaps[0].card.templates:
            for one_link in one_templ.links:
                # 2.1 Не имеет значения, брать терминал или нетерминал,
                #      так как и то и то в равной степени входит в шаблон
                links_names[one_link.non_terminal.the_link] = set()

        # 3. Бежим по локальным свапам перед последним шаблонным (УЖЕ РАЗВЕРНУТЫ!!!)
        for one_swap in local_swaps[1::]:

            # ВРЕМЕННАЯ СТРОКА!! УБРАТЬ!
            # Смотрим на one_swap
            # print(one_swap.replacing)

            # 4. Если замещающее значение в текущем свапе
            #     совпадает с нетерминалом какой-то ссылки в последнем шаблонном свапе,
            #     дополняем в список-значение словаря заменяемый терминал (значение ссылки)
            if one_swap.replacing in links_names.keys():
                links_names[one_swap.replacing].add(one_swap.replaceable)

        # ВРЕМЕННАЯ СТРОКА!! УБРАТЬ!
        # Смотрим на links_names
        # print(links_names)

        # 5. Возвращаем информацию о ссылках
        return links_names

    def _do_one_reverse_swap(self, links_data: dict, templ_swap: OneSwap) -> None:
        """Использует информацию о ссылках и последней шаблонной замене, \n
            чтобы сделать одну обратную замену, \n
            а также добавляет обратный свап в поле self._swaps. \n
        \n
           Принимает: \n
           1. Словарь с именами и значениями ссылок. Если код доехал до сюда, значит коллизий НЕТ!!! \n
           2. Последнюю шаблонную замену \n
         \n
           Возвращает: \n
           None \n
         \n
           1. Создаем переменную под нужный шаблон, \n
               чтобы пучарм не ругался на неинициализированность \n
           2. Находим нужный шаблон \n
           3. Находим позицию шаблона в строке \n
           4. получаем доступ к позициям замен в замещающем значении шаблона \n
           5. Сортируем список позиций во избежание \n
              (и во избежание работаем с копией) \n
           6. Запоминаем последнюю версию строки для того, \n
               чтобы правильно сформировать обратный свап \n
           7. Производим финальную замену! \n
           8. Добавляем обратный свап в поле свапов"""

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # Смотрим на состояние параметров
        # print(links_data, templ_swap.get_fields())

        # 1. Создаем переменную под нужный шаблон,
        #     чтобы пучарм не ругался на неинициализированность
        last_templ = []

        # 2. Находим нужный шаблон
        for one_templ in templ_swap.card.templates:
            if one_templ.name == templ_swap.replacing:
                last_templ = one_templ

        # 3. Находим позицию шаблона в строке
        templ_pos = self._str.find(last_templ.name)

        # 4. получаем доступ к позициям замен в замещающем значении шаблона
        for one_link in last_templ.links:

            # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
            # Смотрим на всякое-разное (меняю в процессе...)
            # print(one_link.non_terminal.get_fields())

            # 5. Сортируем список позиций во избежание
            #    (и во избежание работаем с копией)
            positions = one_link.non_terminal.positions.copy()
            positions.sort()
            for one_pos in positions:
                # 6. Запоминаем последнюю версию строки для того,
                #     чтобы правильно сформировать обратный свап
                prev_str = self._str

                # 7. Производим финальную замену!
                self._str = (self._str[:templ_pos + one_pos] + list(links_data[one_link.non_terminal.the_link])[0] +
                             self._str[templ_pos + one_pos + len(one_link.non_terminal.the_link):])

                # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
                # Смотрим на self._str
                # print(self._str)

                # 8. Добавляем обратный свап в поле свапов
                self._swaps += [OneSwap(prev_str, self._str, one_link.non_terminal.the_link,
                                        list(links_data[one_link.non_terminal.the_link])[0], one_pos,
                                        templ_swap.card)]

    def _prepare_for_reverse_swap(self, local_swaps: List[OneSwap]):
        """Находит все свапы между последними двумя шаблонными свапами \n
            и производит одну обратную замену. \n
        \n
           Принимает список свапов. \n
           Возвращает список из 3ех полей: \n
           (или пустой список, если не было замен по шаблону): \n
            -то, что заменяли в последней шаблонной замене, \n
            -то, на что заменяли в последней шаблонной замене, \n
            -позицию последней шаблонной замены \n
         \n
           1. Проверяем, что пришедшие замены не пустые. \n
              Если пустые - экономим время и просто вернем [] \n
           2. Создадим переменную для шаблонных свапов. \n
              Как только в цикле их наберется 2, прервем цикл (мы нашли, что нам надо) \n
           3. Создаем список свапов после предпоследнего шаблонного \n
              (для обратной замены) \n
           4. Бежим в обратном порядке по всем локальным заменами, пришедшим из параметров \n
               до тех пор, пока \n
               либо не встретим предпоследнюю шаблонную замену (если она была - тогда прервем цикл ниже) \n
               либо не кончатся шаблонные замены (те пройдем локальные свапы до конца) \n
           5. Копим шаблонные свапы. \n
              Как только их накопится 2, прервем цикл (мы нашли, что нам надо) \n
           6. Если накопилось хотя бы 2 шаблонных свапа, прерываем цикл \n
           7. Если была шаблонная замена и только одна \n
               копим свапы после предпоследнего шаблонного \n
               (для обратной замены) \n
           8. Получаем все значения ссылок каждого типа \n
           9. Проверяем, не произошло ли коллизии. \n
              Если нет, производим-таки финальную замену """

        # 1. Проверяем, что пришедшие замены не пустые.
        #    Если пустые - экономим время и просто вернем []
        if not local_swaps:
            return []

        # 2. Создадим переменную для шаблонных свапов.
        #    Как только в цикле их наберется 2, прервем цикл (мы нашли, что нам надо)
        templ_swaps = []

        # 3. Создаем список свапов после предпоследнего шаблонного
        #    (для обратной замены)
        swaps_for_reverse = []

        # 4. Бежим в обратном порядке по всем локальным заменами, пришедшим из параметров
        #     до тех пор, пока
        #     либо не встретим предпоследнюю шаблонную замену (если она была - тогда прервем цикл ниже)
        #     либо не кончатся шаблонные замены (те пройдем локальные свапы до конца)
        for one_swap in local_swaps[::-1]:

            # 5. Копим шаблонные свапы.
            #    Как только их накопится 2, прервем цикл (мы нашли, что нам надо)
            if one_swap.card.templates:
                templ_swaps += [one_swap]

            # 6. Если накопилось хотя бы 2 шаблонных свапа, прерываем цикл
            if len(templ_swaps) > 1:
                break

            # 7. Если была шаблонная замена и только одна
            #     копим свапы после предпоследнего шаблонного
            #     (для обратной замены)
            if len(templ_swaps) == 1:
                swaps_for_reverse += [one_swap]

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # Смотрим на swaps_for_reverse
        # print([one_swap.get_fields() for one_swap in swaps_for_reverse])

        # 8. Получаем все значения ссылок каждого типа
        links_data = self._get_links_data(swaps_for_reverse)

        # 9. Проверяем, не произошло ли коллизии.
        #    Если нет, производим-таки финальную замену
        if not self._collision_occurred(links_data):
            self._do_one_reverse_swap(links_data, local_swaps[-1])

    def _reverse_swaps(self) -> bool:
        """Обратные замены \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
           И! \n
           Добавляет в свапы все обратные замены, \n
           разделяя их, если их >1. \n
        \n
           1. Устанавливаем флажок присутствия замен на False (по-умолчанию) \n
           2. Проверяем, что есть замены, которые можно откатывать \n
           3. Устанавливаем первичные значения для: \n
               -номера шаблонного свапа во всех свапах, \n
               -локальных свапов для параметра self._do_one_reverse_swap(...) \n
              ВАЖНО!!! \n
              Локальные свапы не инвертируют свапы! \n
           4. Перебираем все шаблоны вплоть до первого (от последнего) \n
           5. Если замена шаблонная \n
           6. Производим одну обратную замену \n
           7. Переключаем флажок присутствия замен на True \n
           8. Обрезаем в локальных свапах последнюю шаблонную замену \n
               и обновляем номер шаблонного свапа во всех свапах \n
           9. Возвращаем состояние флажка присутствия замен"""

        # 1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
        swapped = False

        # 2. Проверяем, что есть замены, которые можно откатывать
        if self._swaps:

            # 3. Устанавливаем первичные значения для:
            #     -номера шаблонного свапа во всех свапах,
            #     -локальных свапов для параметра self._last_templ_swap_data(...)
            #    ВАЖНО!!!
            #    Локальные свапы не инвертируют свапы!
            last_swap_i = 0
            local_swaps = self._swaps.copy()

            # 4. Перебираем все шаблоны вплоть до первого (от последнего)
            for swap_i, one_swap in enumerate(self._swaps[::-1]):

                # 5. Если замена шаблонная
                if one_swap.card.templates:
                    # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
                    # Смотрим на local_swaps
                    # print([other_swap.get_fields() for other_swap in local_swaps])

                    # 6. Производим одну обратную замену
                    self._prepare_for_reverse_swap(local_swaps)

                    # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! ПОТОМ УБРАТЬ
                    # Смотрим на
                    # -то, что заменяем,
                    # -то, на что заменяем,
                    # -и позицию замены.
                    # print(replaceable, '|', replacing, '|', replaceable_pos)

                    # 7. Переключаем флажок присутствия замен на True
                    swapped = True

                    # 8. Обрезаем в локальных свапах последнюю шаблонную замену
                    #     и обновляем номер шаблонного свапа во всех свапах
                    local_swaps = local_swaps[:-(swap_i - last_swap_i + 1)]
                    last_swap_i = swap_i

        # 9. Возвращаем состояние флажка присутствия замен
        return swapped

    # ДОПИСАТЬ!!! 8, 5 и 7 пп.
    # 8: _reverse_swaps(...)
    # 5: _selfrefs_swaps(...)
    # 7: id-s ... //CardManager!
    def start_warp_drive(self, user_str: str) -> Result:
        """Производит все нужные манипуляции по заменам в строке в нужном порядке \n
        \n
           Принимает на вход user_str \n
           (можно было сделать её внедрение при создании объекта класса, \n
            но я подумал, что универсальнее будет дать возможность менять её раз от раза, \n
            от вызова к вызову start_warp_drive(...)) \n
         \n
            Возвращает итоговое значение поля self._res \n
         \n
           1. Принимаем и сохраняем в соответствующее поле значение user_str \n
              (1 раз вне цикла) \n
           2. Цикл, пока есть хотя бы одно вхождение \n
              (условие прерывание в цикле) \n
           3. Производим прямые обычные замены. \n
              Попутно дополняем информацию о присутствии замен в swapped \n
           4. Проверка-прерывание цикла:  \n
               если не было ни одной обычной замены, \n
               не будет ни по самоссылкам, ни шаблонных (айдишники?..) \n
           5. Производим прямые замены по самоссылкам. \n
           6. Производим прямые замены по шаблонам. \n
           7. id-s ... \n
           8. Производим обратные замены. \n
           9. Формируем и возвращаем результат Парсера \n
         \n
           P.s.: условием на исключение вероятности вхождения в вечный цикл \n
                 должно быть достаточно проверки в CardManager вида no one name not in any value \n
                 (кроме айдишников - для них, вероятно, потребуется отдельное условие)"""

        # 1. Принимаем и сохраняем в соответствующее поле значение user_str
        #    (1 раз вне цикла)
        self._user_str = user_str

        # 2. Цикл, пока есть хотя бы одно вхождение
        #    (условие прерывание в цикле)
        while True:

            # 3. Производим прямые обычные замены.
            #    Попутно дополняем информацию о присутствии замен в swapped
            swapped = self._simple_swaps()

            # 4. Проверка-прерывание цикла:
            #     если не было ни одной обычной замены,
            #     не будет ни по самоссылкам, ни шаблонных (айдишники?..)
            if not swapped:
                break

            # 5. Производим прямые замены по самоссылкам.
            # self._selfrefs_swaps()

            # 6. Производим прямые замены по шаблонам.
            self._templates_swaps()

            # 7. id-s ...

            # Вспомогательный код: смотрим на под-поля свапов:
            # -то, что,
            # -то, на что заменяли,
            # -и позицию замены.
            # for swap in self._swaps:
            #     pprint(swap.get_fields()[2:5])

        # 8. Производим обратные замены.
        self._reverse_swaps()

        # 9. Формируем и возвращаем результат Парсера
        self._res = Result(self._swaps, ResStrStruct(self._first_str, self._str, self._user_str), self._errors)
        return self._res
