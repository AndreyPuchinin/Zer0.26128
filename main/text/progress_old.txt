V - 1. Дооформить  #01 и #02 тесты
V - 2. Сделать класс ошибки
V - 2.1 Дооформить #0 тест

V - 3. Сделать еще один тест на следующее:
       vals = 124 346 45
       str + 12345

V - 3.1 ТЕСТ #03 НЕ РОБИТ!!! - ИСПРАВЛЯТЬ _suitable_val_entry_in_str(...)

~ -  4. Двигаться дальше по тестам.
V -  #1 - работает!
V -  Следующий на очереди - #11 - РАБОТАЕТ!!
V -> #2 - релизнуть обратные замены
      v - релизнуть _last_templ_swap_data(...) - ПЕРЕДЕЛАТЬ ТАК, ЧТОБЫ
                                                 -то, что заменяем,
                                                 -и то, на что заменяем,
                                                 было не полями шаблона - а ЗНАЧЕНИЯМИ ССЫЛОК!!
      - - ЧИТАТЬ СТАРЫЙ КОД - там какие-то хитрые фокусы))
        - Итак, что я понял. Бежим обратно по свапам от последней шаблонной замены до предпоследней
          (потом обрезаем хвост - все до предпоследнего шаблона)
          Ищем все имена, которые заменялись для каждой ссылки шаблона
          (разделяя их по отдельности друг от друга по типам ссылок)
          Как только в одной структуре для текущего типа ссылки значения ссылки различаются
          КОЛЛИЗИЯ
          если каждый тип ссылки имеет лишь по одному значению,
          произвести обратную замену на данные значения для каждого типа ссылки
          И НЕ ЗАБЫТЬ!! - добавить текущую обратную замену в свапы
          вернуться к пробеганию всех свапов пв поиске шаблонных после урезания хвоста локальных свапов
          (локальные свапы - для передачи в параметры функции. КАКОЙ?????)

  V  -  - доделать _get_links_data(...)
                   _collision_occurred(...)

  V  -  - проверить успешную работу _last_templ_swap_data(...)
                                    _one_reverse_swap(...)
                                    _reverse_swaps(...)
  V  -  - продолжить работать над start_warp_drive(...)

  V  -  - перепрочесть все комментарии к данным методам

1 - #21 - V - исправить _suitable_val_entry_in_str(...)
            - добавить понятие глубины ссылки. Разделить свапы по типам,
              а также итерировать пробеганиями по строке
            - изменить результат _simple_swaps(...)
                                 _selfrefs_swaps(...) //еще не готово - менять нечего
                                 _templates_swaps(...)
                                 _reverse_swaps(...)       <-
              с bool (True/False) на List[OneSwap(...)]      \
          ~ - ДОРАБОТАТЬ class RunningStrData!!               ^
          ! - определить входные и выходные типы f()-ций выше |
            - восстановить тесты с #0 - #2 и доделать #21!

2 - релизнуть тесты с двумя последовательными шаблонами (пока без самоссылок)


+ -  Заменить принцип действия ошибок? (объект класса хранит все значения составляющих ошибки,
                                        в строку это превращается потом)

+ -  В CardManager или Libruary добавить оповещение о том, что библиотека становится слишком большой
     "Слишком большой" определяется скоростью исполнения замен и скоростью добавления карт.
     ИЗМЕРИТЬ!!! (Задача сильно на потом)


!! - Теперь свапы копятся, пока есть хотя бы одно знакомое вхождение в последней версии строки!!
   - значения ссылок обнуляются с каждой шаблонной заменой
   - Условием на исключение вероятности вхождения в вечный цикл
   - должно быть достаточно проверки в CardManager вида no one name not in any value
!! - (кроме айдишников - для них, вероятно, потребуется отдельное условие)"""







+ - добавить тест с двумя шаблонами.
    Выяснить, как соотносится тип теста с двумя шаблонами и прочие типы тестов
    Если надо, то сформировать и добавить все нужные тесты