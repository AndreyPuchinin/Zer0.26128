v - 1.доделать TDD
v - 2.проверить, что все верно перенес
    # 7 и 8 тесте неоднозначны

v - 3.сделать так, чтобы работал тест 0 и 1
v - 3.1 Релизнуть первый п. Прямых замен - найти самое длинное из всех самых близких значений
# -     (можно с нейронкой)
v - 3.2 Проверить тест 0!!

v - Отредактировать класс Swap. Дополнить: было, стало, заменилось, на позиции
v - - Перефрматить тесты (последовательно)

F - Новый дизайн: _simple_swaps & _templ_swaps юзают одну и ту же _straight_swaps!!
v - Починить тесты.
v - Выяснить, почему перед #0 test'ом ничего не пишется
# - - потому что цикл for swap in self._swaps[::-1] в _templates_swaps(...) перебирает пустой массив
! - доделать тест #2
v - - добиться упоминания шаблона в свапе
v - - добиться упоминания предыдущей и текущей версии строки

ТЕСТ #21 - НАЧАТЬ с longest_of_nearest_val (СМ. НИЖЕ)
V - добиться, чтобы работали все тесты вплоть до #2 с добавкой подстроки -в-> inp_str
v - чтобы работал тест #21 с poly_typed links
v - - Добиться зеленого test #21

V - - ОБРАТНЫЕ ЗАМЕНЫ!!!
v  - - -  1 тип ссыли
v  - - - >1 тип ссыли - еще тест!!!
v    - -  плохо работает поиск наидлиннейшего из наиближайших: (longest_of_nearest_val)
v         почему-то слово заменяется раньше числа

V - настраиваемую строку сделать списком из всех возможных выборов:
v - - нач
v - - посл усп
v - - пуст
v - - пользовательская
V - добиться, чтобы работали все пред.тесты с новым форматом res_str (не '' - а [])

!!!!!!!!!!!!!!
||||||||||||||
VVVVVVVVVVVVVV

  - - перепроверить форматы ответов теста #2
  - перепроверить форматы резов прочих тестов

v -  Найти значение всех ссылок
v -   - найти значение на глубине >1
v -   - найти ВСЕ значениЯ по имени ссылки (брать именно из прямых свапов! не из обратных!)


V -   ЕЩЕ РАЗ ПЕРЕРАБОТАТЬ ЭТОТ КУСОК:

V -   Не работает inp_str_1 в  test #2:
V -   (сформировать минимально рабочую задачу!)

v - 0.бежим назад по обр. свапам
v - 1.нашли "слово" в обр. свапах на позиции 45
F - - Учесть pos!
F - - - узнать причины каждого pos!
v - 2.ищем его в списке имен
v - 3.если нашли, добавляем его (предварительно удаляем?) значение в список имен под началом самого первого имени
v - 4.если нет, видимо, замена не по шаблону (ничего не делаем~)
v - 5.продолжаем искать вплоть до первой (нулевой) прямой замены
v - 6.сравниваем все концы списка значений имен по каждому имени
v - 6.1 если есть хотя бы 1 расхождение под началом хотя бы 1-ого имени, КОЛЛИЗИЯ!

F  ->  -   - - учесть при поиске значения pos
F       -   - учесть !=ые pos

V  -   -  Сравнить значения ссылок!
V  -   -  Исправить _not_collision!!!
~  -   -  ДОПОЛНИТЬ ТЕСТ 2+ в глубину обычных замен (без коллизий или с)
!  ->  >   - с коллизией: если одно Число=один, а другое Число=1
F  -       - коллизия?..: глубина ссылок разная, а знчение - одно.
?  -   -                  Возможно ли такое? (каждое значение лишь в одной карте!)
x          - НЕ коллизия! >1шаблона
x            (очередной шаблон обрабатывается очередным прогоном алга Парсера)
v  -   -  добавить одну абракадабру в конец строки в тесте #21

1.v - Найти used_templ
2.v - Найти source для каждого линка (vals!)
3.v - Заменить все линки
 .v - найти все обратные линки name_links (см. F() = 'get_reverse_links')
 .v - заменить обратно ссылки с имен на значения


__init__
//инициализирует поля

longest_of_nearest_val
//находит самое длинное из всех самых близких обычных значений

longest_of_nearest_templ
//находит самое длинное из всех самых близких шаблонных значений
(КОПИПАСТА longest_of_nearest_val с одним только изменением!:
for one_template in card.templates: ...)

longest_of_nearest_selfrefs
//находит самое длинное из всех самых близких значений-самоссылок
(КОПИПАСТА longest_of_nearest_val с одним только изменением!:
for val in card.selfrefs: ...)

_simple_swaps
//прямые замены

_selfrefs_swaps
//прямые замены самоссылок

_templates_swaps
//шаблонные замены

_get_used_templ
//находит шаблон из последнего свапа

_link_name_reverse
//разворачивает список с разделенным на подстроки именем самоссылки

get_selfrefs_links_one_name(_links_name_and_val, ...)
//принимает
  список объектов структуры из двух полей:
  того, что заменяли, и того, на что заменяли
//возвращает
  primary_name (имя первой ссылки из поданнго на вход списка),
  res_name (конечное значение первой ссылки)
           (в последний момент становится по значению res_val)

get_link_names
//возвращает словарь: имя = имя ссылки,
                      значение = список: первый элемент повторяет ключ
                                         далее - все конечные значения
                                         если хотя бы одно значение далее разнится - КОЛЛИЗИЯ!!
//переместил в class SelfrefLinksData
//В Парсере её больше нет!

_not_collision
//проверяет равенство всех значений ссылок
  копит ошибку, если надо

_get_reverse_links
//возвращает словарь:
  левое поле - позиция
  правое - список из 2ух полей [что заменяли, на что заменяли]

_reverse_swaps
//производит обратные замены

start_warp_drive
//запускает прямые, шаблонные и обратные замены



start_warp_drive <- _simple_swaps, _selfrefs_swaps, _templates_swaps, _reverse_swaps


_simple_swaps <- longest_of_nearest_val

_selfrefs_swaps <- _simple_swaps <- longest_of_nearest_selfrefs

_templates_swaps <- _simple_swaps <- longest_of_nearest_templ

_reverse_swaps <- _get_used_templ, _not_collision, _get_reverse_links


_get_used_templ <- 0

_not_collision <- get_link_names (в классе SelfrefLinksData)

get_link_names <- 0

_get_reverse_links <- 0



['дважды (число плюс слово) плюс слово',
 'число плюс слово плюс число плюс слово плюс слово',
 [[['число', [8]], ['число', [0, 22]]],
  [['слово', [31, 19]], ['слово', [11, 33, 44]]]]]

templ_1_link_name = ['число', [8]]
templ_1_link_val = ['число', [0, 22]]

templ_2_link_name = ['слово', [31, 19]]
templ_2_link_val  = ['слово', [11, 33, 44]]



V - - 0+  -  ....
V - - 1.   #2  = one link (pos)
V - - 2.   #21 = poly_typed links (pos)
V - - 3.   #3  = COLLISION
V - - 3.1  #31 = COLLISION POLY TYPED (one collision)
V - - 3.2  #32 = COLLISION POLY TYPED (some collisions)
V -   -    +   - исправить ошибки коллизии, чтобы не повторяли значения!
V - - 4.   #4  = selfref + temple test (pos)
F              - Почему-то алг не видит шаблона...
V   -          - сочленяем значения столько раз, сколько их в самоссыллке
V   -          - добавить символ в конец самоссылки
#              - -  добавил (вокруг значений)
F   -          - распараллелить самоссылки и шалоны (не работает обратная замена! починить!!)

V   - 4.1  #41 = selfref + temple pos test (poly_typed links)
v   -          - - ПЕРЕРАБОТАТЬ get_selfrefs_links_names !!!
v   -          - - - Найти метод поиска значений самоссылки в [[other_swap.link_val, other_swap.link_name] for other_swap in self._swaps]
v   -          - - - В #4 тесте ')' прибавляется к res_name в get_selfrefs_links_one_name НЕ В КОНЦЕ
v   -          - - - ТЕСТ 4 РОБИТ, 41 - НЕТ. Исправить!!!


F   -          - Описать комментами все классы в начале файла!!
V              - - еще раз выписать все f()-ции, их параметры и типы
!   -          - - к каждому методу Parser'а дописать коммент и возвращаемый тип
!!  -          - - - добить комменты к _link_name_reverse(...) и get_selfrefs_links_one_name(...)
                     тоже нужны классы-структуры. Возможно, даже всего 1!!
V              - - - если надо, создать по классу на каждый нужный возвращаемый тип
V              - - + можно некоторые функции из Parser'а перекинуть в эти классы
V              - - - Убедиться, что все работает!

Новые классы:
-SelfrefLinksData
-CollisionInfo
-новый класс LinkSwapInfo для результата Parser._get_reverse_links() <----!!!!!!!
--поля и методы! релизнуть <----!!!!!!!

!!  ->         - Исправить в тесте #42 последовательность накопления содержимого ошибок:
!                  '(1-один)' или '(один-1)'

X   -          - - - добавить три значения подряд '(1-1-1)' вместо двух '(1-1)' для ссылки 'число'
X   -          - - - ПРОВЕРИТЬ, ЧТО РАБОТАЕТ!!

  - - 5.   #5  = selfref + collision  test ( one typed link )
  - - 5.1  #51 = selfref + collision  test (poly_typed links)
                 - добавить три значения подряд '(1-1-1)' вместо двух '(1-1)' для ссылки 'число'
                 - ПРОВЕРИТЬ, ЧТО РАБОТАЕТ!!

  # --- ID-s ---
  - - 6.   #6  = id-s test (pos)
  - - 7.   #7  = selfref + id-s test (pos)
  + + 7.1  #71 = selfref + id-s test (poly_typed links)
  - - 8.   #8  = id-. in inp_str (neg!)

  - + 9.   Card Manager !
  + + 10   Filters?..

v - - создать новую структуру под Темплейт (2+ типов ссылок, 1+ ссылок)
v - проверить актуальность структуры свапа. (включил карту в поле) Как откатить?
+ - Структура темплейта идеальна. После обратных замен повторяем весь парс,
    пока преобразованная строка не совпадет с предыдущей (или коллизия).
+ - !!!Проверить все вероятности циклов!!!

? - Расширить ошибку коллизии до многого количества значений ссылки
? - + для каждого типа ссылки!


Как откатить? Нужны ли свапы (обычные (вроде нет) и самоссыльные (вроде да) -
вплоть до шаблонных?). Контрпример:

13+123 -> (12)3+123 -> 123+123 -> A+A -> 123*2
# A = 123, 321
# A+A -> 123+123

123x+123x -> word+word -> w(ord)+w(ord) -> w(seq)+w(seq) -проверка на коллизии!-> w(A+wA) -> w2*A ->
w2*(seq) -> w2*(ord) -> w*2word -> w*123x

проверка на коллизии:
1.Найти наидлинную из наиближайших вхождений значения темплейта
2.Считать первичные значения ссылок
3.Сверить значения ссылок
4.Если есть хотя бы одно расхождение, вернуть коллизию и настраиваемую строку-результат
5.Если нет, заменить ссылки на их первичные значения

123x,  123x  -> word+word     # ссылка = word,  значение = 123x
word,  word  -> w(ord)+w(ord) # ссылка = (ord), значение = word
(ord), (ord) -> w(seq)+w(seq) # ссылка = (seq), значение = (ord)
(seq), (seq) -> w(A+wA)       # ссылка = A, значение = (seq)

A+wA         -> 2*A
A            -> (seq)


# если откат автоматом, то:
2*A   -> 2*123x : w2*123x

# 123x+(ord)
# 2A -> 2 <!!collision!!> : w2