from typing import List
from abc import ABC, abstractmethod
# from pprint import pprint
# from webbrowser import open_new_tab


# Библиотеку ниже подключал для съемки видео
# Внутри на время убрал if __name__ == '__main__':
# ...и при запуске данного файла получал вывод всех тестов
# (а также работали и отсюда)
# from OLD_main import OLD_main_from_FLASH_CARD


class ZeroEntity(ABC):
    @abstractmethod
    def __init__(self) -> None:
        pass

    @abstractmethod
    def get_fields(self) -> list:
        pass


"""V - ЗАМЕНИТЬ ИМЯ И ЗНАЧЕНИЕ НА ТЕРМИНАЛ И НЕТЕРМИНАЛ!!! - 
       ЭТО РЕШИТ ПРОБЛЕМУ СОВПАДЕНИЯ ПОНЯТИЙ 'ЗНАЧЕНИЯ'"""


class LinkData(ZeroEntity):
    """Конечные поля ссылки (link): \n
       1.строка (будь то терминал или нетерминал шаблона или самоссылки) \n
       2.список позиций вхождений в терминал или нетерминал шаблона или самоссылки"""

    def __init__(self, the_link: str, pos: List[int]) -> None:
        """Устанавливает и хранит поля ссылки (link): \n
           1.строку (будь то терминал или нетерминал шаблона или самоссылки), \n
           2.а также все позиции вхождения данной строки в терминал или нетерминал шаблона или самоссылки"""
        self.the_link = the_link
        self.pos = pos

    def get_fields(self) -> list:
        """Вернет списком \n
           1.строку (будь то терминал или нетерминал шаблона или самоссылки), \n
           2.а также все позиции вхождения данной строки в терминал или нетерминал шаблона или самоссылки"""
        return [self.the_link, self.pos]


class Link(ZeroEntity):
    """Шаблонная ссылка (template link) или ссылка самоссылки (selfref link): \n
       ПОЛЯ (2): \n
       1.терминалы (значения), \n
       2.нетерминал (имя). \n
       (Оба поля является объектами LinkData)"""

    def __init__(self, non_terminals: LinkData, terminals: LinkData) -> None:
        """Устанавливает и хранит 2 ПОЛЯ: \n
           1.терминалы (значения) \n
           2.нетерминал (имя) \n
           шаблонной ссылки (template link) \n
           или \n
           ссылки самоссылки (selfref link). \n
           (Оба поля являются объектами LinkData)"""
        self.non_terminal = non_terminals
        self.terminal = terminals

    def get_fields(self) -> list:
        """Вернет список из подсписков - \n
           полей шаблонной ссылки (template link) \n
           или \n
           ссылки самоссылки (selfref link) \n
           (В обоих случаях поля являются объектами LinkData)"""
        return [
            [link for link in self.non_terminal.get_fields()],
            [link for link in self.terminal.get_fields()]
        ]


class Template(ZeroEntity):
    """Шаблонное значение: \n
       ПОЛЯ (3): \n
       1.строка имени, \n
       2.строка шаблонного значения,
       3.информация о ссылках (объекты класса Link) внутри шаблонного значения"""

    def __init__(self, name: str, val: str, links: List[Link]) -> None:
        """Устанавливает и хранит 3 поля: \n
           1.строку имени, \n
           2.строку шаблонного значения, \n
           3.информацию о ссылках (объекты класса Link) внутри шаблонного значения"""
        self.name = name
        self.val = val
        self.links = links

    def get_fields(self) -> list:
        """Вернет списком 3 поля: \n
           1.строку имени, \n
           2.строку шаблонного значения, \n
           3.информацию о ссылках (объекты класса Link) внутри шаблонного значения"""
        return [self.name, self.val,
                [one_link.get_fields() for one_link in self.links]
                ]


class SelfRef(ZeroEntity):
    """Значение-самоссылка: \n
       ПОЛЯ (3): \n
       1.строка имени, \n
       2.строка значения-самоссылки,
       3.информация о ссылках (объекты класса Link) внутри значения-самоссылки"""

    def __init__(self, name: str, vals: List[str], links: List[Link]) -> None:
        """Устанавливает и хранит 3 поля: \n
           1.строку имени, \n
           2.строку значения-самоссылки \n
           3.информацию о ссылках (объекты класса Link) внутри значения-самоссылки"""
        self.name = name
        self.vals = vals
        self.links = links

    def get_fields(self) -> list:
        """Вернет списком 3 поля: \n
           1.строку имени, \n
           2.строку значения-самоссылки \n
           3.информацию о ссылках (объекты класса Link) внутри значения-самоссылки"""
        return [self.name, self.vals,
                [one_link.get_fields() for one_link in self.links]
                ]


class Card(ZeroEntity):
    """Класс Карточки \n
       ПОЛЯ (4 или 5): \n
       1.имя карточки, \n
       2.обычные значения карточки, \n
       3.значения-самоссылки, \n
       4.шаблонные значения, \n
       (+5.значения, одновременно шаблонные и самоссылки. \n
           Эти значения можно попытаться исключить из кода, \n
           запустив алгоритм для одного значения такого типа \n
           сперва для самоссылок, \n
           а затем для шаблонов)"""

    def __init__(self, name: str, usual_vals: List[str], selfrefs: List[SelfRef],
                 templates: List[Template]) -> None:  # templ_refs) -> None:
        """Устанавливает и хранит 4 (или 5) полей: \n
           1.имя карточки, \n
           2.обычные значения карточки, \n
           3.значения-самоссылки, \n
           4.шаблонные значения, \n
           (+5.значения, одновременно шаблонные и самоссылки. \n
               Эти значения можно попытаться исключить из кода, \n
               запустив алгоритм для одного значения такого типа \n
               сперва для самоссылок, \n
               а затем для шаблонов)"""
        self.name = name
        self.usual_vals = usual_vals
        self.selfrefs = selfrefs
        self.templates = templates
        # self.templ_refs = []  # по идее можно дополнить в selfrefs, а потом в templates

    def get_fields(self) -> list:
        """Вернет списком 4 (или 5) полей: \n
           1.имя карточки, \n
           2.обычные значения карточки, \n
           3.значения-самоссылки, \n
           4.шаблонные значения, \n
           (+5.значения, одновременно шаблонные и самоссылки. \n
               Эти значения можно попытаться исключить из кода, \n
               запустив алгоритм для одного значения такого типа \n
               сперва для самоссылок,  \n
               а затем для шаблонов)"""
        return [self.name,
                self.usual_vals,
                [selfrefs.get_fields() for selfrefs in self.selfrefs],
                [template.get_fields() for template in self.templates],
                # self.templ_refs
                ]


class Errors(ZeroEntity):
    """Класс ошибки. \n
       ПОЛЯ (пока 2): \n
       1.Накопленные ошибки \n
       \n
       КОНСТАНТЫ (пока 1): \n
       2.1 БЕЗ ОШИБОК \n
       \n
       ПРОЧИЕ КОНСТАНТЫ ФОРМИРУЮТСЯ ПАРАМЕТРИЗИРУЕМЫМИ МЕТОДАМИ"""

    def __init__(self):
        """Устанавливает и хранит (пока) 2 поля:\n
           1.Накопленные ошибки \n
           \n
           КОНСТАНТЫ (пока 1): \n
           2.1 'БЕЗ ОШИБОК' \n
           \n
           ПРОЧИЕ КОНСТАНТЫ ФОРМИРУЮТСЯ ПАРАМЕТРИЗИРУЕМЫМИ МЕТОДАМИ"""
        self._errors = []

        self._no_errors = 'Успешно, ошибок нет!'
        # ...
        pass

    def get_fields(self):
        """Вернет списком 1-но поле \n
           (...И ЭТО РАБОЧИЙ ВАРИАНТ КОДА!!!): \n
           1.накопленные ошибки"""
        return self._errors

    def no_errors(self):
        """Сброс накапливания ошибок в 0. \n
           Положит в поле накопленных ошибок ТОЛЬКО константу \n
           'БЕЗ ОШИБОК'"""
        self._errors = [self._no_errors]
        return self._errors

    def errors_caught(self):
        """Удаление константы 'БЕЗ ОШИБОК' из накопленных ошибок. \n
           ВЫЗЫВАТЬ ИЗ КАЖДОГО МЕТОДА класса Errors, \n
           ГДЕ КОПИТСЯ ОШИБКА!!!"""
        while self._no_errors in self._errors:
            self._errors.remove(self._no_errors)

    def collision(self, terminal: str, non_terminals: List[str]):
        """Дополнит в поле накопленных ошибок строку о коллизии. \n
           \n
           ПАРАМЕТРЫ (2): \n
            \n
           1.нетерминал \n
           (имя шаблонной ссылки (template link) \n
           или \n
           ссылки самоссылки (selfref link)) \n
           \n
           2.терминалы \n
           (значения шаблонной ссылки (template link) \n
           или \n
           ссылки самоссылки (selfref link))"""
        self.errors_caught()
        res_str = 'Коллизия! Неясно, на что заменять \'' + terminal + '\' - на \'' + non_terminals[0] + '\''
        for one_link_val in non_terminals[1:-1]:
            res_str += ', \'' + one_link_val + '\''
        res_str += ' или \'' + non_terminals[-1] + '\''
        self._errors += [res_str]
        return self._errors


class Swap(ZeroEntity):
    """Класс замены. \n
       ПОЛЯ (6): \n
       1. Последняя версия строки \n
       2. Новая версия строки \n
       3. Что заменяем \n
       4. На что заменяем \n
       5. Позиция замены в строке (хоть в старой, хоть в новой - они =ы) \n
       6. Карточка, которая применяется для замены"""

    def __init__(self, prev_str: str, new_str: str, replaceable, replacing, pos, card: Card):
        """Устанавливает и хранит 6 полей: \n
           1. Последняя версия строки \n
           2. Новая версия строки \n
           3. Что заменяем \n
           4. На что заменяем \n
           5. Позиция замены в строке (хоть в старой, хоть в новой - они =ы) \n
           6. Карточка, которая применяется для замены"""
        self.prev_str = prev_str
        self.new_str = new_str
        self.replaceable = replaceable
        self.replacing = replacing
        self.pos = pos
        self.card = card

    def get_fields(self):
        """Вернет списком 6 полей: \n
           1.Последняя версия строки \n
           2.Новая версия строки \n
           3.Что заменяем \n
           4.На что заменяем \n
           5.Позиция замены в строке (хоть в старой, хоть в новой - они =ы) \n
           6.Карточка, которая применяется для замены"""
        return [self.prev_str,
                self.new_str,
                self.replaceable,
                self.replacing,
                self.pos,
                self.card.get_fields()]


class ResStrStruct(ZeroEntity):
    """Структура результирующих строк \n
       ПОЛЯ (3): \n
       1.первая строка, \n
       2.последняя успешная строка \n
       3.пользовательская настраиваемая строка"""

    def __init__(self, first_str: str, last_successful: str, user_str: str):
        """Устанавливает и хранит 3 поля: \n
           1.первая строка, \n
           2.последняя успешная строка \n
           3.пользовательская настраиваемая строка"""
        self.first_str = first_str
        self.last_successful = last_successful
        # self.empty = ''
        self.user_str = user_str

    def get_fields(self):
        """Вернет списком 3 поля: \n
           1.первая строка, \n
           2.последняя успешная строка \n
           3.пользовательская настраиваемая строка"""
        return [self.first_str,
                self.last_successful,
                # self.empty,
                self.user_str]


class Result(ZeroEntity):
    """Класс для проверки предполагаемого результата ПАРСИНГА \n
       ПОЛЯ (3): \n
       1. Свапы, \n
       2. 3 строки (класс ResStrStruct выше) \n
       3. ошибки"""

    def __init__(self, swaps: list[Swap], res_str: ResStrStruct, errors: Errors):
        """Устанавливает и хранит 3 поля: \n
           1. Свапы, \n
           2. 3 строки (класс ResStrStruct выше) \n
           3. ошибки"""
        self.swaps = swaps
        self.res_str = res_str
        self.errors = errors

    def get_fields(self):
        """Вернет списком 3 поля: \n
           1. Свапы, \n
           2. 3 строки (класс ResStrStruct выше) \n
           3. ошибки"""
        return [
            [swap.get_fields() for swap in self.swaps],
            self.res_str.get_fields(),
            self.errors.get_fields()
        ]


# Класс Parser НЕ наследуется от ZeroEntity,
# тк ему не нужен get_fields()
class Parser:
    """Класс Парсера \n
       ПОЛЯ (7): \n
       1.Карты \n
       2.Начальная строка \n
       3.Пользовательская строка (меняется от вызова к вызову warp_drive'а) \n
       4.Текущая преобразуемая строка \n
       5.Замены \n
       6.Ошибки \n
       7.Объект результата (класса Result)"""

    # инициализирует все поля
    def __init__(self, cards: List[Card], inp_str: str):
        """Устанавливает и хранит 7 полей \n
           1.Карты \n
           2.Начальная строка \n
           3.Пользовательская строка (меняется от вызова к вызову warp_drive'а) \n
           4.Текущая преобразуемая строка \n
           5.Замены \n
           6.Ошибки \n
           7.Объект результата (класса Result)"""
        self._cards = cards
        self._first_str = inp_str
        self._user_str = None
        self._str = inp_str
        self._swaps = []
        self._errors = Errors()
        self._errors.no_errors()
        self._res = Result([], ResStrStruct('', '', ''), self._errors)

        # Не обязательно, если вызывается внутри каждого метода Error, где копится ошибка
        # self._errors.no_errors()

        self._res = Result([], ResStrStruct('', '', ''), self._errors)

    @staticmethod
    def _suitable_val_entry_in_str(sentence: str,
                                   words_data_list: List[List[str | Card]]) -> (List[str | int | Card] |
                                                                                None):
        """Получает на вход строку и список из подсписков из \n
             имени, \n
             нужного значения карточки, \n
             самой карты (нужно для свапов при обратных заменах) \n
        \n
           Возвращает подходящее вхождение в строку \n
            из множества значений нужного типа \n
            в формате [link_name, link_val, card, pos] \n
            или None, если вхождений нет \n
        \n
           1. Принимаем за потенциальный ответ None. \n
               Если не будет найдено ни одного вхождения, результат = None! \n
           2. Бежим по входной строке. \n
           3. На каждом шаге сортируем по длине от самой короткой до самой длинной все входные строки, \n
               начинающиеся на текущий символ. \n
           4. Спрашиваем для каждой, входит ли она полностью во входную строку. \n
           5. Если да, заменяем потенциальный ответ на более длинный. \n
               и дополняем позицию первого вхождения в возвращаемый результат \n
           6. Если нет, просто едем дальше. \n
           7. Если найдено хотя бы одно вхождение строки - прерываем цикл \n
           8. Если нет, возвращаем список типа words_data из одного word'а и card'а."""

        # 1. Принимаем за потенциальный ответ None.
        #                Если не будет найдено ни одного вхождения, результат = None!
        res_word_data = None

        # 2. Бежим по входной строке.
        for char in sentence:

            # 3. На каждом шаге сортируем по длине от самой короткой до самой длинной все входные строки,
            #                начинающиеся на текущий символ.
            matched_words_data_list = sorted([data for data in words_data_list if data[1][0] == char], key=len)

            # 4. Спрашиваем для каждой, входит ли она полностью во входную строку.
            # 5. Если да, заменяем потенциальный ответ на более длинный
            #     и дополняем позицию первого вхождения в возвращаемый результат
            for matched_words_data in matched_words_data_list:
                if matched_words_data[1] in sentence:
                    first_entry = sentence.find(matched_words_data[1])
                    res_word_data = matched_words_data + [first_entry]

            # 6. Если нет, просто едем дальше.
            # 7. Если найдено хотя бы одна вхождение строки - прерываем цикл
            if res_word_data is not None:
                # print('FINISH', res_word_data)
                break

        # 8. Когда вся строка перебрана, вернуть список типа words_data с word'ами и card'ами.
        return res_word_data

    def _do_swaps(self, words: List[List[str | Card]]) -> bool:
        """ Замены (см. п. 4 ниже)
        \n
            Принимает на вход список из подсписков из \n
             -имени карты, \n
             -значения нужного типа, \n
             -ссылки на карту. \n
        \n
            Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
           2. Пока есть вхождения (прерывание с условием внутри цикла) \n
           3. Получаем результат-структуру после поиска вхождений в строку обычных значений \n
           4. Условие прерывания (если больше НЕТ вхождений) \n
           5. Если вхождение есть...: \n
           5.1 Переключаем флажок присутствия замен на True
           5.2 Находим из найденной структуры выше \n
                имя, \n
                одно значение, подходящее по вхождению, \n
                соответствующую карту, \n
                и позицию вхождения значения \n
           5.3 Сохраняем последнее состояние строки \n
           5.4 Обновляем состояние строки: \n
               Заменяем в строке значение на имя \n
           5.5 Формируем текущий свап: \n
                сохраняем последнее состояние строки, \n
                новое, \n
                значение замены, \n
                нужное имя, \n
                позицию замены, \n
                и соответствующую карточку \n
           5.6 Добавляем текущий сформированный свап в общий список свапов \n
           6. Возвращаем состояние флажка присутствия замен"""

        # 1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
        swapped = False

        # 2. Пока есть вхождения (прерывание с условием внутри цикла)
        while True:

            # 3. Получаем результат-структуру после поиска вхождений в строку обычных значений
            found_val = self._suitable_val_entry_in_str(self._str, words)
            # print(found_val)

            # 4. Условие прерывания (если больше НЕТ вхождений)
            if found_val is None:
                break

            # 5. Если вхождение есть...:
            else:

                # 5.1 Переключаем флажок присутствия замен на True
                swapped = True

                # 5.2 Находим из найденной структуры выше
                #      имя,
                #      одно значение, подходящее по вхождению,
                #      соответствующую карту,
                #      и позицию вхождения значения
                found_link_name, found_link_val, found_card, found_pos = found_val

                # 5.3 Сохраняем последнее состояние строки
                last_version_of_str = self._str

                # 5.4 Обновляем состояние строки:
                #     Заменяем в строке значение на имя
                self._str = self._str.replace(found_link_val, found_link_name, 1)

                # 5.5 Формируем текущий свап:
                #      сохраняем последнее состояние строки,
                #      новое,
                #      значение замены,
                #      нужное имя,
                #      позицию замены,
                #      и соответствующую карточку
                cur_swap = Swap(last_version_of_str, self._str, found_link_val, found_link_name, found_pos, found_card)

                # 5.6 Добавляем текущий сформированный свап в общий список свапов
                self._swaps += [cur_swap]

        # 6. Возвращаем состояние флажка присутствия замен
        return swapped

    def _simple_swaps(self) -> bool:
        """Прямые замены \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Формируем список из подсписков из \n
               -имени карты, \n
               -значения нужного типа, \n
               -ссылки на карту. \n
           2. Выполняем простые замены \n
               и одним махом возвращаем информацию о присутствии замен"""

        # 1. Формируем список из подсписков из
        #      -имени карты,
        #      -значения нужного типа,
        #      -ссылки на карту.
        words = [[[card.name, val, card] for val in card.usual_vals] for card in self._cards][0]
        # print(words)

        # 2. Выполняем простые замены
        #     и одним махом возвращаем информацию о присутствии замен
        return self._do_swaps(words)

    def _templates_swaps(self) -> bool:
        """Замены по шаблону (БЕЗ ОБРАТНЫХ!!) \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
        \n
           1. Формируем список из подсписков из \n
               -имени карты, \n
               -значения нужного типа, \n
               -ссылки на карту. \n
           2. Выполняем замены по шаблону (БЕЗ ОБРАТНЫХ!!)
               и одним махом возвращаем информацию о присутствии замен
        """

        # 1. Формируем список из подсписков из
        #      -имени карты,
        #      -значения нужного типа,
        #      -ссылки на карту.
        words = [[[one_template.name, one_template.val, card] for one_template in card.templates][0]
                 for card in self._cards if card.templates]
        # print(words)

        # 2. Выполняем замены по шаблону (БЕЗ ОБРАТНЫХ!!)
        #     и одним махом возвращаем информацию о присутствии замен
        return self._do_swaps(words)

    # ДОПИСАТЬ!!!  (ПРОВЕРИТЬ СО ВСЕМ ИТОГОВО!!)
    def _collision_occurred(self, links_data: dict) -> bool:
        """Определяет, произошла ли коллизия при последней замене по шаблону
            из всех локальных свапов, пришедших извне

           Принимает локальные свапы после предпоследнего шаблонного.
           Возвращает True, если коллизия была,
            и False, если не произошла
            (те если все значения совпадают в рамках каждого типа).

           1. Создаем список под каждую возможную коллизию под ссылку каждого типа
           2. Бежим по локальным свапам
           3. Дополняем в список возможных коллизий итоговый ответ для каждого типа ссылки
           4. Если была хотя бы одна коллизия - возвращаем False"""

        # 1. Создаем список под каждую возможную коллизию под ссылку каждого типа
        collisions_list = []

        # 2. Бежим по локальным свапам
        for one_link_data in links_data:

            # 3. Дополняем в список возможных коллизий итоговый ответ для каждого типа ссылки
            collisions_list += [not all(one_link_val == links_data[one_link_data][0]
                                for one_link_val in links_data[one_link_data])]

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # Смотрим на collisions_list
        # print(collisions_list)

        # 4. Если была хотя бы одна коллизия - возвращаем False
        return True in collisions_list

    # ДОПИСАТЬ!!! (ПРОВЕРИТЬ СО ВСЕМ ИТОГОВО!!)
    def _get_links_data(self, local_swaps: List[Swap]) -> dict:
        """Возвращает значения ссылок, расфасованные по типам

           Принимает локальные свапы после предпоследнего шаблонного (РАЗВЕРНУТЫЕ!!!).
           Возвращает dict() с ключами = именам ссылок последней шаблонной замены
            и значениями = значениями каждой ссылки
            между последней и предпоследней шаблонной

           1. Создаем словарь для имен (в качестве ключа) и значений (в качестве значений в списке) ссылок
           2. Заполняем ключи нетерминалами ссылок из последнего шаблонного свапа
           2.1 Не имеет значения, брать терминал или нетерминал,
                так как и то и то в равной степени входит в шаблон
           3. Бежим по локальным свапам перед последним шаблонным в обратном порядке
           4. Если замещающее значение в текущем свапе
               совпадает с нетерминалом какой-то ссылки в последнем шаблонном свапе,
               дополняем в список-значение словаря заменяемый терминал (значение ссылки)
           5. Возвращаем информацию о ссылках"""

        # 1. Создаем словарь для имен (в качестве ключа) и значений (в качестве значений в списке) ссылок
        links_names = dict()

        # 2. Заполняем ключи нетерминалами ссылок из последнего шаблонного свапа
        for one_templ in local_swaps[0].card.templates:
            for one_link in one_templ.links:
                # 2.1 Не имеет значения, брать терминал или нетерминал,
                #      так как и то и то в равной степени входит в шаблон
                links_names[one_link.non_terminal.the_link] = []

        # 3. Бежим по локальным свапам перед последним шаблонным в обратном порядке
        for one_swap in local_swaps[-2::-1]:

            # 4. Если замещающее значение в текущем свапе
            #     совпадает с нетерминалом какой-то ссылки в последнем шаблонном свапе,
            #     дополняем в список-значение словаря заменяемый терминал (значение ссылки)
            if one_swap.replacing in links_names:
                links_names[one_swap.replacing] += [one_swap.replaceable]

        # ВРЕМЕННАЯ СТРОКА!! УБРАТЬ!
        # Смотрим на links_names
        # print(links_names)

        # 5. Возвращаем информацию о ссылках
        return links_names

    # ДОПИСАТЬ!!! ДООПИСАТЬ, ДОСТРОИТЬ, ДОЗАДОКУМЕНТИРОВАТЬ!!
    def _get_reverse_swap_data(self, links_data: dict, templ_swap: Swap) -> List[str | int]:
        """Преобразует информацию о ссылках в
           -то, что надо заменить,
           -то, на что нао заменить,
           -и позицию замены.

           Принимает:
           1. Словарь с именами и значениями ссылок. Если код доехал до сюда, значит коллизий НЕТ!!!
           2. Последнюю шаблонную замену

           Возвращает:
           -то, что надо заменить,
           -то, на что надо заменить,
           -и позицию замены"""

        replaceable = templ_swap.replaceable
        replaceable_pos = templ_swap.pos


    # ДОПИСАТЬ!!! 10 п.
    # 10: _get_reverse_swap_data(...)
    def _last_templ_swap_data(self, local_swaps: List[Swap]) -> List[str | str | int | None]:
        """Находит все свапы между последними двумя шаблонными свапами \n
            и производит одну обратную замену. \n
        \n
           Принимает список свапов. \n
           Возвращает список из 3ех полей: \n
           (или пустой список, если не было замен по шаблону): \n
            -то, что заменяли в последней шаблонной замене, \n
            -то, на что заменяли в последней шаблонной замене, \n
            -позицию последней шаблонной замены \n
         \n
           1. Проверяем, что пришедшие замены не пустые.
              Если пустые - экономим время и просто вернем []
           2. Создаем переменную-результат \n
              Если шаблонов в свапах больше не осталось, \n
               вернем [] \n
           3. Создадим переменную для шаблонных свапов. \n
              Как только в цикле их наберется 2, прервем цикл (мы нашли, что нам надо) \n
           4. Создаем список свапов после предпоследнего шаблонного
              (для обратной замены)
           5. Бежим в обратном порядке по всем локальным заменами, пришедшим из параметров \n
               до тех пор, пока \n
               либо не встретим предпоследнюю шаблонную замену (если она была - тогда прервем цикл ниже) \n
               либо не кончатся шаблонные замены (те пройдем локальные свапы до конца) \n
           6. Копим шаблонные свапы. \n
              Как только их накопится 2, прервем цикл (мы нашли, что нам надо) \n
           7. Если накопилось хотя бы 2 шаблонных свапа, прерываем цикл \n
           8. Если была шаблонная замена и только одна
               копим свапы после предпоследнего шаблонного
               (для обратной замены)
           9. Получаем все значения ссылок каждого типа \n
           10. Проверяем, не произошло ли коллизии. \n
              Если нет, формируем результат как \n
              -то, что заменяли в последней шаблонной замене, \n
              -то, на что заменяли в последней шаблонной замене, \n
              -позицию последней шаблонной замены \n
              ЗДЕСЬ ЗАГЛУШКА!!! УБРАТЬ!! \n
           11. Возвращаем результат"""

        # 1. Проверяем, что пришедшие замены не пустые.
        #    Если пустые - экономим время и просто вернем []
        if not local_swaps:
            return []

        # 2. Создаем переменную-результат
        #    Если шаблонов в свапах больше не осталось, (МЫ ТОЛЬКО ЧТО УБЕДИЛИСЬ, ЧТО НЕТ!!!)
        #     вернем []
        # res = []

        # 3. Создадим переменную для шаблонных свапов.
        #    Как только в цикле их наберется 2, прервем цикл (мы нашли, что нам надо)
        templ_swaps = []

        # 4. Создаем список свапов после предпоследнего шаблонного
        #    (для обратной замены)
        swaps_for_reverse = []

        # 5. Бежим в обратном порядке по всем локальным заменами, пришедшим из параметров
        #     до тех пор, пока
        #     либо не встретим предпоследнюю шаблонную замену (если она была - тогда прервем цикл ниже)
        #     либо не кончатся шаблонные замены (те пройдем локальные свапы до конца)
        for one_swap in local_swaps[::-1]:

            # 6. Копим шаблонные свапы.
            #    Как только их накопится 2, прервем цикл (мы нашли, что нам надо)
            if one_swap.card.templates:
                templ_swaps += [one_swap]

            # 7. Если накопилось хотя бы 2 шаблонных свапа, прерываем цикл
            if len(templ_swaps) > 1:
                break

            # 8. Если была шаблонная замена и только одна
            #     копим свапы после предпоследнего шаблонного
            #     (для обратной замены)
            if len(templ_swaps) == 1:
                swaps_for_reverse += [one_swap]

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # Смотрим на swaps_for_reverse
        # print([one_swap.get_fields() for one_swap in swaps_for_reverse])

        # 9. Получаем все значения ссылок каждого типа
        links_data = self._get_links_data(swaps_for_reverse)

        # 10. Проверяем, не произошло ли коллизии.
        #    Если нет, формируем результат как
        #    -то, что заменяли в последней шаблонной замене,
        #    -то, на что заменяли в последней шаблонной замене,
        #    -позицию последней шаблонной замены
        #    ЗДЕСЬ ЗАГЛУШКА!!! УБРАТЬ!!
        if not self._collision_occurred(links_data):
            self._get_reverse_swap_data(links_data, local_swaps[-1])
            res = ['', '', 0]

        # 11. Возвращаем результат
        return res

    # ДОПИСАТЬ!!! (ПРОВЕРИТЬ, ЧТО РАБОТАЕТ!!)
    def _one_reverse_swap(self, replaceable: str, replacing: str, replaceable_pos: int, card: Card) -> None:
        """Производит одну обратную замену \n
         \n
           Принимает на вход 4 параметра: \n
            -то, что заменяли, \n
            -то, на что заменяли, \n
            -позицию замены в строке, \n
            -карточку, шаблон которой использован \n
           Ничего не возвращает (None) \n
         \n
           1. Сохраняем последнюю версию строки, \n
               чтобы сохранить её в свап \n
           2. Производим обратную замену \n
           3. Дополняем обратный свап в поле всех свапов"""

        # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
        # print(replaceable, '|', replacing, '|', replaceable_pos)

        # 1. Сохраняем последнюю версию строки,
        #     чтобы сохранить её в свап
        prev_str = self._str

        # 2. Производим обратную замену
        self._str = self._str[replaceable_pos:] + replacing + self._str[:replaceable_pos + len(replaceable)]

        # 3. Дополняем обратный свап в поле всех свапов
        self._swaps += [Swap(prev_str, self._str, replaceable, replacing, replaceable_pos, card)]

    # ДОПИСАТЬ!!! 6 и 7 пп.
    # 6: self._last_templ_swap_data(...)
    # 7: self._one_reverse_swap(...)
    def _reverse_swaps(self) -> bool:
        """Обратные замены \n
        \n
           Ничего не принимает, \n
           Возвращает True, если замены были, \n
           и False, если нет. \n
           И! \n
           Добавляет в свапы все обратные замены, \n
           разделяя их, если их >1. \n
        \n
           1. Устанавливаем флажок присутствия замен на False (по-умолчанию) \n
           2. Проверяем, что есть замены, которые можно откатывать \n
           3. Устанавливаем первичные значения для: \n
               -номера шаблонного свапа во всех свапах, \n
               -локальных свапов для параметра self._last_templ_swap_data(...) \n
              ВАЖНО!!! \n
              Локальные свапы не инвертируют свапы! \n
           4. Перебираем все шаблоны вплоть до первого (от последнего) \n
           5. Если замена шаблонная \n
           6. Получаем информацию для обратной замены \n
              По идее, условие выше означает, что результат функции строкой ниже \n
               не может быть []! \n
           7. Производим обратную замену \n
               и переключаем флажок присутствия замен на True \n
               (была хотя бы одна обратная замена). \n
              Добавление обратных свапов в список свапов \n
               произойдет внутри self._one_reverse_swap(...) \n
           8. Обрезаем в локальных свапах последнюю шаблонную замену \n
               и обновляем номер шаблонного свапа во всех свапах \n
           9. Возвращаем состояние флажка присутствия замен"""

        # 1. Устанавливаем флажок присутствия замен на False (по-умолчанию)
        swapped = False

        # 2. Проверяем, что есть замены, которые можно откатывать
        if self._swaps:

            # 3. Устанавливаем первичные значения для:
            #     -номера шаблонного свапа во всех свапах,
            #     -локальных свапов для параметра self._last_templ_swap_data(...)
            #    ВАЖНО!!!
            #    Локальные свапы не инвертируют свапы!
            last_swap_i = 0
            local_swaps = self._swaps.copy()

            # 4. Перебираем все шаблоны вплоть до первого (от последнего)
            for swap_i, one_swap in enumerate(self._swaps[::-1]):

                # 5. Если замена шаблонная
                if one_swap.card.templates:

                    # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! УБРАТЬ!!
                    # Смотрим на local_swaps
                    # print([other_swap.get_fields() for other_swap in local_swaps])

                    # 6. Получаем информацию для обратной замены
                    #    По идее, условие выше означает, что результат функции строкой ниже
                    #     не может быть []!
                    # replaceable, replacing, replaceable_pos =
                    self._last_templ_swap_data(local_swaps)

                    # ВСПОМОГАТЕЛЬНАЯ СТРОКА!! ПОТОМ УБРАТЬ
                    # Смотрим на
                    # -то, что заменяем,
                    # -то, на что заменяем,
                    # -и позицию замены.
                    # print(replaceable, '|', replacing, '|', replaceable_pos)

                    # 7. Производим обратную замену
                    #     и переключаем флажок присутствия замен на True
                    #     (была хотя бы одна обратная замена).
                    #    Добавление обратных свапов в список свапов
                    #     произойдет внутри self._one_reverse_swap(...)
                    # self._one_reverse_swap(replaceable, replacing, replaceable_pos, one_swap.card)
                    swapped = True

                    # 8. Обрезаем в локальных свапах последнюю шаблонную замену
                    #     и обновляем номер шаблонного свапа во всех свапах
                    local_swaps = local_swaps[:-(swap_i - last_swap_i + 1)]
                    last_swap_i = swap_i

        # 9. Возвращаем состояние флажка присутствия замен
        return swapped

    # ДОПИСАТЬ!!! 8, 5 и 7 пп.
    # 8: _reverse_swaps(...)
    # 5: _selfrefs_swaps(...)
    # 7: id-s ... //CardManager!
    def start_warp_drive(self, user_str: str) -> Result:
        """Производит все нужные манипуляции по заменам в строке в нужном порядке \n
        \n
           Принимает на вход user_str \n
           (можно было сделать её внедрение при создании объекта класса, \n
            но я подумал, что универсальнее будет дать возможность менять её раз от раза, \n
            от вызова к вызову start_warp_drive(...)) \n
         \n
            Возвращает итоговое значение поля self._res \n
         \n
           1. Принимаем и сохраняем в соответствующее поле значение user_str \n
              (1 раз вне цикла) \n
           2. Цикл, пока есть хотя бы одно вхождение \n
              (условие прерывание в цикле) \n
           3. Производим прямые обычные замены. \n
              Попутно дополняем информацию о присутствии замен в swapped \n
           4. Проверка-прерывание цикла:  \n
               если не было ни одной обычной замены, \n
               не будет ни по самоссылкам, ни шаблонных (айдишники?..) \n
           5. Производим прямые замены по самоссылкам. \n
           6. Производим прямые замены по шаблонам. \n
           7. id-s ... \n
           8. Производим обратные замены. \n
           9. Формируем и возвращаем результат Парсера

           P.s.: условием на исключение вероятности вхождения в вечный цикл
                 должно быть достаточно проверки в CardManager вида no one name not in any value
                 (кроме айдишников - для них, вероятно, потребуется отдельное условие)"""

        # 1. Принимаем и сохраняем в соответствующее поле значение user_str
        #    (1 раз вне цикла)
        self._user_str = user_str

        # 2. Цикл, пока есть хотя бы одно вхождение
        #    (условие прерывание в цикле)
        while True:

            # 3. Производим прямые обычные замены.
            #    Попутно дополняем информацию о присутствии замен в swapped
            swapped = self._simple_swaps()

            # 4. Проверка-прерывание цикла:
            #     если не было ни одной обычной замены,
            #     не будет ни по самоссылкам, ни шаблонных (айдишники?..)
            if not swapped:
                break

            # 5. Производим прямые замены по самоссылкам.
            # self._selfrefs_swaps()

            # 6. Производим прямые замены по шаблонам.
            self._templates_swaps()

            # 7. id-s ...

            # Вспомогательный код: смотрим на под-поля свапов:
            # -то, что,
            # -то, на что заменяли,
            # -и позицию замены.
            # for swap in self._swaps:
            #     pprint(swap.get_fields()[2:5])

        # 8. Производим обратные замены.
        self._reverse_swaps()

        # 9. Формируем и возвращаем результат Парсера
        self._res = Result(self._swaps, ResStrStruct(self._first_str, self._str, self._user_str), self._errors)
        return self._res


class Tests:
    def __init__(self):
        pass

    def run_all_tests(self):
        print('#0', self.test_0(), '\n')

        print('#01', self.test_01(), '\n')
        print('#02', self.test_02(), '\n')
        print('#03', self.test_03(), '\n')

        print('#1', self.test_1(), '\n')
        print('#11', self.test_11(), '\n')

        print('#2', self.test_2(), '\n')
        # print('#21', self.test_21(), '\n')
        # print('#3', self.test_3(), '\n')
        # print('#31', self.test_31(), '\n')
        # print('#32', self.test_32(), '\n')
        # print('#4', self.test_4(), '\n')
        # print('#41', self.test_41(), '\n')
        # print('#42', self.test_42(), '\n')

        # print('#5', self.test_5(), '\n')

        # print('#6', self.test_6(), '\n')
        # print('#7', self.test_7(), '\n')
        # print('#8', self.test_8(), '\n')

    # Чисто проверяем, что тест запускается
    # (тест ничего не делает! - нет замен, список свапов пуст)
    def test_0(self):
        card1 = Card('число', ['один'], [], [])
        inp_str = '.1'
        user_str = 'user_str'
        swaps = []
        res_str = '.1'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # Проверяем Parser._suitable_val_entry_in_str(...)
    def test_01(self):
        card1 = Card(' один два ', ['1', '12', '1235', '124', '234567', '345678'], [], [])
        inp_str = '01234567'
        user_str = 'user_str'
        swaps = [Swap('01234567', '0 один два 34567', '12', ' один два ', 1, card1)]
        res_str = '0 один два 34567'
        error = Errors()
        error.no_errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # Чуть > сложная проверка Parser._suitable_val_entry_in_str(...)
    def test_02(self):
        card1 = Card(' три->семь ', ['1235', '124', '34567', '345678'], [], [])
        inp_str = '01234567'
        user_str = 'user_str'
        swaps = [Swap('01234567', '012 три->семь ', '34567', ' три->семь ', 3, card1)]
        res_str = '012 три->семь '
        error = Errors()
        error.no_errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # Еще чуть > сложная проверка Parser._suitable_val_entry_in_str(...)
    def test_03(self):
        card1 = Card(' один два ', ['12'], [], [])
        inp_str = '1312'
        user_str = 'user_str'
        swaps = [Swap('1312', '13 один два ', '12', ' один два ', 2, card1)]
        res_str = '13 один два '
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # одна обычная замена без шаблона
    def test_1(self):
        card1 = Card('число', ['один', '1'], [], [])
        inp_str = '.один'
        user_str = 'user_str'
        swaps = [Swap('.один', '.число', 'один', 'число', 1, card1)]
        res_str = '.число'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # две обычные замены без шаблона
    def test_11(self):
        card1 = Card('число', ['один', 'два'], [], [])
        inp_str = '.один плюс один'
        user_str = 'user_str'
        swaps = [Swap('.один плюс один', '.число плюс один', 'один', 'число', 1, card1),
                 Swap('.число плюс один', '.число плюс число', 'один', 'число', 12, card1)]
        res_str = '.число плюс число'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # простейшая замена по шаблону (pos)
    def test_2(self):
        # Карта 1 = 'число' / 'один', 'два'
        card1 = Card('число', ['один', 'три'], [], [])

        # Карта 2 (шаблон!) = 'дважды число' / 'число плюс число'
        # Настраиваем шаблон:
        first_non_terminal_links = LinkData('число', [7])
        first_terminal_links = LinkData('число', [0, 11])
        some_templ_links = Link(first_non_terminal_links, first_terminal_links)

        card2_template = Template('дважды число', 'число плюс число',
                                  [some_templ_links])

        # Сохраняем в шаблон
        card2 = Card('дважды число', [], [], [card2_template])

        user_str = 'user_str'
        inp_str = '.один плюс один.'

        swaps = [Swap('.один плюс один.', '.число плюс один.',
                      'один', 'число', 1, card1),
                 Swap('.число плюс один.', '.число плюс число.',
                      'один', 'число', 12, card1),
                 #
                 # templ_swap
                 Swap('.число плюс число.', '.дважды число.',
                      'число плюс число', 'дважды число', 1, card2)
                 #
                 # reverse swaps
                 # Swap('.дважды число.', '.дважды один.',
                 #     'один', 'число', 7, card2),
                 ]
        res_str = '.дважды один.'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # замена по шаблону с двумя типами ссылок (pos)
    def test_21(self):
        card1 = Card('число', ['один', 'два'], [], [])
        # ДОПОЛНИТЬ В SWAPS ЗАМЕНУ 1 -> один -> число
        card4 = Card('один', ['1'])
        card3 = Card('слово', ['абракадабра', 'абракадаб'])
        card2 = Card('дважды (число плюс слово) плюс слово', [])
        name_links1 = LinkData('число', [8])
        vals_links1 = LinkData('число', [0, 22])
        name_links2 = LinkData('слово', [31, 19])
        vals_links2 = LinkData('слово', [11, 33, 44])

        card2_link1 = Link(name_links1, vals_links1)
        card2_link2 = Link(name_links2, vals_links2)

        card2.templates = [Template('дважды (число плюс слово) плюс слово',
                                    'число плюс слово плюс число плюс слово плюс слово',
                                    [card2_link1, card2_link2])]
        inp_str = '.1 плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра'
        user_str = 'user_str'
        swaps = [Swap('.1 плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '1', 'один', 1, card4),
                 Swap('.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      'один', 'число', 1, card1),
                 Swap('.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс 1 плюс абракадабра плюс абракадабра', 'абракадабра',
                      'слово', 12, card3),
                 Swap('.число плюс слово плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс один плюс абракадабра плюс абракадабра',
                      '1', 'один', 23, card4),
                 Swap('.число плюс слово плюс один плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс число плюс абракадабра плюс абракадабра',
                      'один', 'число', 23, card1),
                 Swap('.число плюс слово плюс число плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс число плюс слово плюс абракадабра', 'абракадабра',
                      'слово', 34, card3),
                 Swap('.число плюс слово плюс число плюс слово плюс абракадабра',
                      '.число плюс слово плюс число плюс слово плюс слово', 'абракадабра',
                      'слово', 45, card3),

                 # templ_swap
                 Swap('.число плюс слово плюс число плюс слово плюс слово',
                      '.дважды (число плюс слово) плюс слово',
                      'число плюс слово плюс число плюс слово плюс слово',
                      'дважды (число плюс слово) плюс слово',
                      1, card2)

                 # reverse swaps
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (число плюс слово) плюс абракадабра',
                 #      'абракадабра', 'слово', 32, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра) плюс слово',
                 #      'абракадабра', 'слово', 19, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра)',
                 #      '1', 'число', 8, card2),
                 ]
        res_str = '.дважды (1 плюс абракадабра) плюс абракадабра'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # коллизия с одним типом ссылки (pos)
    def test_3(self):
        card1 = Card('число', ['один', 'два'], [], [])
        # card2 = Card('дважды число', ['число плюс число'])
        card2 = Card('дважды число', [], [], [])

        name_links1 = LinkData('число', [7])
        vals_links1 = LinkData('число', [0, 11])

        card2_link1 = Link(name_links1, vals_links1)

        card2.templates += [Template('дважды число', 'число плюс число', [card2_link1])]

        inp_str = '.один плюс два.'
        user_str = 'user_str'
        swaps = [
            # прямые замены
            Swap('.один плюс два.', '.число плюс два.', 'один', 'число', 1, card1),
            Swap('.число плюс два.', '.число плюс число.', 'два', 'число', 12, card1),

            # шаблонные замены
            Swap('.число плюс число.', '.дважды число.', 'число плюс число', 'дважды число', 1, card2)
        ]
        res_str = '.дважды число.'  # в 3 тесте эта строка настраивается юзером!
        error = Errors()
        error.collision('число', ['один', 'два'])
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # коллизия с двумя типами ссылки (pos test)
    def test_31(self):
        card1 = Card('число', ['один', 'два'])
        # ДОПОЛНИТЬ В SWAPS ЗАМЕНУ 1 -> один -> число
        card4 = Card('один', ['1'])
        card3 = Card('слово', ['абракадабра', 'абракадаб'])
        card2 = Card('дважды (число плюс слово) плюс слово', [])
        name_links1 = LinkData('число', [8])
        vals_links1 = LinkData('число', [0, 22])
        name_links2 = LinkData('слово', [31, 19])
        vals_links2 = LinkData('слово', [11, 33, 44])

        card2_link1 = Link(name_links1, vals_links1)
        card2_link2 = Link(name_links2, vals_links2)

        card2.templates = [Template('дважды (число плюс слово) плюс слово',
                                    'число плюс слово плюс число плюс слово плюс слово',
                                    [card2_link1, card2_link2])]

        inp_str = '.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра'
        user_str = 'user_str'
        swaps = [Swap('.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      'один', 'число', 1, card1),
                 Swap('.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс 1 плюс абракадабра плюс абракадабра', 'абракадабра',
                      'слово', 12, card3),
                 Swap('.число плюс слово плюс 1 плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс один плюс абракадабра плюс абракадабра',
                      '1', 'один', 23, card4),
                 Swap('.число плюс слово плюс один плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс число плюс абракадабра плюс абракадабра',
                      'один', 'число', 23, card1),
                 Swap('.число плюс слово плюс число плюс абракадабра плюс абракадабра',
                      '.число плюс слово плюс число плюс слово плюс абракадабра', 'абракадабра',
                      'слово', 34, card3),
                 Swap('.число плюс слово плюс число плюс слово плюс абракадабра',
                      '.число плюс слово плюс число плюс слово плюс слово', 'абракадабра',
                      'слово', 45, card3),

                 # templ_swap
                 Swap('.число плюс слово плюс число плюс слово плюс слово',
                      '.дважды (число плюс слово) плюс слово',
                      'число плюс слово плюс число плюс слово плюс слово',
                      'дважды (число плюс слово) плюс слово',
                      1, card2)

                 # reverse swaps
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (число плюс слово) плюс абракадабра',
                 #      'абракадабра', 'слово', 32, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра) плюс слово',
                 #      'абракадабра', 'слово', 19, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра)',
                 #      '1', 'число', 8, card2),
                 ]
        res_str = '.дважды (число плюс слово) плюс слово'
        error = Errors()
        error.collision('число', ['один', '1'])
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # коллизия с двумя типами ссылки (neg test)
    def test_32(self):
        card1 = Card('число', ['один', 'два'])
        # ДОПОЛНИТЬ В SWAPS ЗАМЕНУ 1 -> один -> число
        card4 = Card('один', ['1'])
        card3 = Card('слово', ['абракадабра', 'абракадаб'])
        card2 = Card('дважды (число плюс слово) плюс слово', [])
        name_links1 = LinkData('число', [8])
        vals_links1 = LinkData('число', [0, 22])
        name_links2 = LinkData('слово', [31, 19])
        vals_links2 = LinkData('слово', [11, 33, 44])

        card2_link1 = Link(name_links1, vals_links1)
        card2_link2 = Link(name_links2, vals_links2)

        card2.templates = [Template('дважды (число плюс слово) плюс слово',
                                    'число плюс слово плюс число плюс слово плюс слово',
                                    [card2_link1, card2_link2])]

        inp_str = '.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадаб'
        user_str = 'user_str'
        swaps = [Swap('.один плюс абракадабра плюс 1 плюс абракадабра плюс абракадаб',
                      '.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадаб',
                      'один', 'число', 1, card1),
                 Swap('.число плюс абракадабра плюс 1 плюс абракадабра плюс абракадаб',
                      '.число плюс слово плюс 1 плюс абракадабра плюс абракадаб', 'абракадабра',
                      'слово', 12, card3),
                 Swap('.число плюс слово плюс 1 плюс абракадабра плюс абракадаб',
                      '.число плюс слово плюс один плюс абракадабра плюс абракадаб',
                      '1', 'один', 23, card4),
                 Swap('.число плюс слово плюс один плюс абракадабра плюс абракадаб',
                      '.число плюс слово плюс число плюс абракадабра плюс абракадаб',
                      'один', 'число', 23, card1),
                 Swap('.число плюс слово плюс число плюс абракадабра плюс абракадаб',
                      '.число плюс слово плюс число плюс слово плюс абракадаб', 'абракадабра',
                      'слово', 34, card3),
                 Swap('.число плюс слово плюс число плюс слово плюс абракадаб',
                      '.число плюс слово плюс число плюс слово плюс слово', 'абракадаб',
                      'слово', 45, card3),

                 # templ_swap
                 Swap('.число плюс слово плюс число плюс слово плюс слово',
                      '.дважды (число плюс слово) плюс слово',
                      'число плюс слово плюс число плюс слово плюс слово',
                      'дважды (число плюс слово) плюс слово',
                      1, card2)

                 # reverse swaps
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (число плюс слово) плюс абракадабра',
                 #      'абракадабра', 'слово', 32, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра) плюс слово',
                 #      'абракадабра', 'слово', 19, card2),
                 # Swap('.дважды (число плюс слово) плюс слово',
                 #      '.дважды (1 плюс абракадабра)',
                 #      '1', 'число', 8, card2),
                 ]
        res_str = '.дважды (число плюс слово) плюс слово'
        error = Errors()
        error.collision('число', ['один', '1'])
        error.collision('слово', ['абракадабра', 'абракадабра', 'абракадаб'])
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields() != res.get_fields()

    # самоссылка + шаблон
    # selfref + temple test
    def test_4(self):
        card1 = Card('число', ['один', 'двадцать'])
        selfref_links1 = LinkData('(число-число)', [1, 7])
        card1.selfrefs = [selfref_links1]

        card2 = Card('дважды число', [])
        one_name_links = LinkData('число', [7])
        one_vals_links = LinkData('число', [0, 11])
        many_temp_links = Link(one_name_links, one_vals_links)
        card2.templates = [Template('дважды число', 'число плюс число',
                                    [many_temp_links])]

        inp_str = '.(двадцать-один) плюс (двадцать-один).'
        user_str = 'user_str'
        swaps = [Swap('.(двадцать-один) плюс (двадцать-один).',
                      '.(число-один) плюс (двадцать-один).',
                      'двадцать', 'число', 2, card1),
                 Swap('.(число-один) плюс (двадцать-один).',
                      '.(число-число) плюс (двадцать-один).',
                      'один', 'число', 8, card1),
                 Swap('.(число-число) плюс (двадцать-один).',
                      '.(число-число) плюс (число-один).',
                      'двадцать', 'число', 21, card1),
                 Swap('.(число-число) плюс (число-один).',
                      '.(число-число) плюс (число-число).',
                      'один', 'число', 27, card1),
                 Swap('.(число-число) плюс (число-число).',
                      '.число плюс (число-число).',
                      '(число-число)', 'число', 1, card1),
                 Swap('.число плюс (число-число).',
                      '.число плюс число.',
                      '(число-число)', 'число', 12, card1),

                 # замены по шаблону
                 Swap('.число плюс число.',
                      '.дважды число.',
                      'число плюс число', 'дважды число', 1, card2),
                 ]
        # 'дважды число',
        # 'дважды двадцать один']
        res_str = '.дважды (двадцать-один).'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # самоссылка (selfref) + шаблон с двумя типами ссылки
    def test_41(self):
        card1 = Card('число', ['один', 'два'])
        selfref_links1 = LinkData('(число-число)', [1, 7])
        card1.selfrefs = [selfref_links1]
        # ДОПОЛНИТЬ В SWAPS ЗАМЕНУ 1 -> один -> число
        card4 = Card('один', ['1'])
        card3 = Card('слово', ['абракадабра', 'абракадаб'])
        card2 = Card('дважды (число плюс слово) плюс слово', [])
        name_links1 = LinkData('число', [8])
        vals_links1 = LinkData('число', [0, 22])
        name_links2 = LinkData('слово', [31, 19])
        vals_links2 = LinkData('слово', [11, 33, 44])

        card2_link1 = Link(name_links1, vals_links1)
        card2_link2 = Link(name_links2, vals_links2)

        card2.templates = [Template('дважды (число плюс слово) плюс слово',
                                    'число плюс слово плюс число плюс слово плюс слово',
                                    [card2_link1, card2_link2])]

        # print(card1.get_fields())
        # print(card2.get_fields())
        # print(card3.get_fields())
        # print(card4.get_fields())

        inp_str = '.(1-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра'
        user_str = 'user_str'
        swaps = [Swap('.(1-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(один-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 2, card4),
                 Swap('.(один-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 2, card1),
                 Swap('.(число-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-один) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 8, card4),
                 Swap('.(число-один) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 8, card1),
                 Swap('.(число-число) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (1-1) плюс абракадабра плюс абракадабра',
                      'абракадабра', 'слово', 20, card3),
                 Swap('.(число-число) плюс слово плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (один-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 32, card4),
                 Swap('.(число-число) плюс слово плюс (один-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 32, card1),
                 Swap('.(число-число) плюс слово плюс (число-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-один) плюс абракадабра плюс абракадабра',
                      '1', 'один', 38, card4),
                 Swap('.(число-число) плюс слово плюс (число-один) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс абракадабра плюс абракадабра',
                      'один', 'число', 38, card1),

                 Swap('.(число-число) плюс слово плюс (число-число) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс слово плюс абракадабра',
                      'абракадабра', 'слово', 50, card3),
                 Swap('.(число-число) плюс слово плюс (число-число) плюс слово плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс слово плюс слово',
                      'абракадабра', 'слово', 61, card3),

                 # selfrefs_swaps
                 Swap('.(число-число) плюс слово плюс (число-число) плюс слово плюс слово',
                      '.число плюс слово плюс (число-число) плюс слово плюс слово',
                      '(число-число)', 'число', 1, card1),
                 Swap('.число плюс слово плюс (число-число) плюс слово плюс слово',
                      '.число плюс слово плюс число плюс слово плюс слово',
                      '(число-число)', 'число', 23, card1),

                 # templ_swap
                 Swap('.число плюс слово плюс число плюс слово плюс слово',
                      '.дважды (число плюс слово) плюс слово',
                      'число плюс слово плюс число плюс слово плюс слово',
                      'дважды (число плюс слово) плюс слово',
                      1, card2)
                 ]
        res_str = '.дважды ((1-1) плюс абракадабра) плюс абракадабра'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # самоссылки (selfref) с разной степенью глубины +
    # + шаблон (templ) с двумя типами ссылки, (~neg!~)
    def test_42(self):
        card1 = Card('число', ['один', 'два'])
        selfref_links1 = LinkData('(число-число)', [1, 7])
        card1.selfrefs = [selfref_links1]
        # ДОПОЛНИТЬ В SWAPS ЗАМЕНУ 1 -> один -> число
        card4 = Card('один', ['1'])
        card3 = Card('слово', ['абракадабра', 'абракадаб'])
        card2 = Card('дважды (число плюс слово) плюс слово', [])
        name_links1 = LinkData('число', [8])
        vals_links1 = LinkData('число', [0, 22])
        name_links2 = LinkData('слово', [31, 19])
        vals_links2 = LinkData('слово', [11, 33, 44])

        card2_link1 = Link(name_links1, vals_links1)
        card2_link2 = Link(name_links2, vals_links2)

        card2.templates = [Template('дважды (число плюс слово) плюс слово',
                                    'число плюс слово плюс число плюс слово плюс слово',
                                    [card2_link1, card2_link2])]

        # print(card1.get_fields())
        # print(card2.get_fields())
        # print(card3.get_fields())
        # print(card4.get_fields())

        inp_str = '.(1-1) плюс абракадабра плюс (1-один) плюс абракадабра плюс абракадабра'
        user_str = 'user_str'
        swaps = [Swap('.(1-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(один-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 2, card4),
                 Swap('.(один-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 2, card1),
                 Swap('.(число-1) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-один) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 8, card4),
                 Swap('.(число-один) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 8, card1),
                 Swap('.(число-число) плюс абракадабра плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (1-1) плюс абракадабра плюс абракадабра',
                      'абракадабра', 'слово', 20, card3),
                 Swap('.(число-число) плюс слово плюс (1-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (один-1) плюс абракадабра плюс абракадабра',
                      '1', 'один', 32, card4),
                 Swap('.(число-число) плюс слово плюс (один-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-1) плюс абракадабра плюс абракадабра',
                      'один', 'число', 32, card1),
                 Swap('.(число-число) плюс слово плюс (число-1) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-один) плюс абракадабра плюс абракадабра',
                      '1', 'один', 38, card4),
                 Swap('.(число-число) плюс слово плюс (число-один) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс абракадабра плюс абракадабра',
                      'один', 'число', 38, card1),

                 Swap('.(число-число) плюс слово плюс (число-число) плюс абракадабра плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс слово плюс абракадабра',
                      'абракадабра', 'слово', 50, card3),
                 Swap('.(число-число) плюс слово плюс (число-число) плюс слово плюс абракадабра',
                      '.(число-число) плюс слово плюс (число-число) плюс слово плюс слово',
                      'абракадабра', 'слово', 61, card3),

                 # selfrefs_swaps
                 Swap('.(число-число) плюс слово плюс (число-число) плюс слово плюс слово',
                      '.число плюс слово плюс (число-число) плюс слово плюс слово',
                      '(число-число)', 'число', 1, card1),
                 Swap('.число плюс слово плюс (число-число) плюс слово плюс слово',
                      '.число плюс слово плюс число плюс слово плюс слово',
                      '(число-число)', 'число', 23, card1),

                 # templ_swap
                 Swap('.число плюс слово плюс число плюс слово плюс слово',
                      '.дважды (число плюс слово) плюс слово',
                      'число плюс слово плюс число плюс слово плюс слово',
                      'дважды (число плюс слово) плюс слово',
                      1, card2)
                 ]
        res_str = '.дважды ((1-1) плюс абракадабра) плюс абракадабра'
        error = Errors()
        error.no_errors()
        res = Result(swaps, ResStrStruct(inp_str, res_str, user_str), error)
        print(Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields())
        print(res.get_fields())
        return Parser([card1, card2, card3, card4], inp_str).start_warp_drive(user_str).get_fields() == res.get_fields()

    # самоссылка (selfref) + коллизия (collision)
    def test_5(self):
        card1 = Card('число', ['один', 'два', 'число число'])
        card2 = Card('дважды число', ['число плюс число'])
        inp_str = 'один два плюс два один'
        swaps = ['один два плюс два один',
                 'число два плюс два один',
                 'число число плюс два один',
                 'число число плюс число один',
                 'число число плюс число число',
                 'число плюс число число',
                 'число плюс число',
                 'дважды число']
        res_str = 'число плюс число'  # в 5 тесте строка настраивается (тк не было успешной шаблонной замены)
        error = Errors()
        error.collision('число', 'один два', 'два один')
        res = Result(swaps, res_str, error)
        return Parser([card1, card2], inp_str).start_warp_drive().get_fields() == res.get_fields()

    # идентификаторы (id-s), (pos)
    def test_6(self):
        card1 = Card('число', ['один', 'два', 'число число', 'число.число'])
        card2 = Card('число.два плюс число.один', ['число.один плюс число.два'])
        inp_str = 'один плюс два'
        swaps = ['один плюс два',
                 'число плюс два',
                 'число плюс число',
                 'два плюс один']
        res_str = 'два плюс один'
        error = Errors()
        error.no_errors()
        res = Result(swaps, res_str, error)
        return Parser([card1, card2], inp_str).start_warp_drive().get_fields() == res.get_fields()

    # самоссылки (selfref) + идентификаторы (id-s)
    def test_7(self):
        card1 = Card('число', ['один', 'два', 'число число', 'число.число'])
        card2 = Card('число.два плюс число.один', ['число.один плюс число.два'])
        inp_str = 'один плюс два один'
        error = Errors()
        error.no_errors()
        swaps = ['один плюс два один',
                 'число плюс два один',
                 'число плюс число один',
                 'число плюс число число',
                 'число плюс число',
                 'два один плюс один']
        res_str = 'два один плюс один'
        res = Result(swaps, res_str, error)
        return Parser([card1, card2], inp_str).start_warp_drive().get_fields() == res.get_fields()

    # нетерминал идентификатора внутри входной строки (neg!)
    # должен работать априори при всех пред. успешно работающих тестах
    # Те тратить силы на его доработку по идее не надо (если все пойдет хорошо)
    def test_8(self):
        card1 = Card('число', ['один', 'два', 'число число', 'число.число'])
        card2 = Card('число.два плюс число.один', ['число.один плюс число.два'])
        inp_str = 'один.один плюс два'
        error = Errors()
        error.no_errors()
        swaps = ['один.один плюс два',
                 'число.один плюс два',
                 'число.число плюс два',
                 'число.число плюс число']
        res_str = 'число плюс число'  # настраивается! Не было замен по шаблону
        res = Result(swaps, res_str, error)
        return Parser([card1, card2], inp_str).start_warp_drive().get_fields() == res.get_fields()


if __name__ == '__main__':
    Tests().run_all_tests()
